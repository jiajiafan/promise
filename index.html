<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>promises</title>
  <link rel="stylesheet" href="assets/stylesheet.css">
</head>

<body class="spec">
 Promises/A+
 一个开放、健全、通用的 JavaScript Promise 标准——由开发者制定，供开发者参考

 一个 promise 代表异步操作的最终结果。 和一个promise交互的主要方法是通过它的 then 方法,它注册了回调函数来接收 promise 的最终value 和 不能被 fulfilled 的reason。

 此规范详细说明了 then 方法的行为, 所有符合Promises/A+规范的 promise实现，都可以依靠提供的基础进行操作。因此，这个规范是非常稳定的。 尽管Promises/A+组织
 会不定期采用向下兼容的方式做一些微调，来修订次规范， 去改变最新发现的边界情况。我们只有在仔细的考虑, 讨论和测试之后才会做一些大的修改或者向后不兼容的改变。

 在历史上, Promises/A+ 只是把 早期的 Promises/A 提议的行为条款阐明, 并扩展它覆盖 事实上的所有行为，并省略了一些不足和不确定的部分.

 最终, 这个核心的 Promises/A+ 规范 不能处理 如何去创建fulfill, 或reject promises, 反而决定去集中于提供一个可共同操作的then 方法。 未来在指南规范中可能提及这些主题。

 术语
 “promise” 是一个具有符合此规范的then 方法的对象或者函数
 “thenable” 是一个对象或者函数，并附带着一个 then 方法
 “value” 是一个任意合法的javaScript值（包括including undefined,thenable 或 promise).
 “exception” 是一个用 throw 语句抛出的值
 “reason” 是一个表明promise被rejected的原因的值
 要求
 Promise 状态
 一个promise必须是这三种状态中的一种: pending, fulfilled, 或rejected.

 当状态为pending时, 这个promise:
 可能会变成 fulfilled 或者 rejected 状态。
 当状态为fulfilled, 这个promise:
 不可以转变为其他任意一种状态
 必须有个value，并且不可改变
 当状态为rejected时, 这个promise:
 不可以转变为其他任意一种状态
 必须有一个reason, 并且不可改变。
 在这里, “不可改变” 意思是不可改变的身份 (i.e. ===), 并不意味着深层次的不可改变。

 then 方法
 每个promise必须提供一个 then 方法接收当前的或者最终的value或reason；

 每个promise的 then 方法接受两个参数

 promise.then(onFulfilled, onRejected)
 onFulfilled 和 onRejected 都是可选参数:
 如果 onFulfilled 不是一个函数, 它应该被忽略。
 如果onRejected is 不是一个函数, 它应该被忽略。
 如果onFulfilled 是一个函数:
 它必须在 promise 状态为fulfilled时被调用, 并且 promise的vallue值是它的第一个参数
 它在 promise 状态转变为fulfilled前不可以被调用。
 它只可以被调用一次
 如果 onRejected 是一个函数,
 它必须在 promise 状态为rejected时被调用, 并且 promise的reason值是它的第一个参数
 它在 promise 状态转为rejected前不可以被调用。
 它只可以被调用一次。
 onFulfilled或onRejected 不可以被调用,直到执行上下文 栈只包含平台代码。 [3.1].
 onFulfilled 和 onRejected 必须作为一个函数来调用 (i.e.即没有 this ). [3.2]
 同一个promisethen 可能被调用多次。
 当 promise 状态是fulfilled时, 所有的onFulfilled 回调函数必须按照它们创建的顺序，交给各自的then来调用
 当promise 状态是rejected时,所有的 onRejected 回调函数必须按照它们创建的顺序，交给各自的 then来调用
 then 必须返回一个 promise [3.3].

 promise2 = promise1.then(onFulfilled, onRejected);
 如果 onFulfilled 或onRejected 返回了一个 x值, 运行下面的代码解决过程： [[Resolve]](promise2, x)。
 如果 onFulfilled 或 onRejected 抛出一个 异常 e, promise2 状态一定是 rejected ，并且 e 就是reason.
 如果 onFulfilled 不是一个函数，并且 promise1 状态是fulfilled， promise2 状态一定是fulfilled ，并且有一个与 promise1相同的 value。
 如果 onRejected不是一个函数，并且promise1的状态是rejected, promise2 状态一定是rejected,并且有一个与 promise1相同的 reason。
 The Promise 解决过程
 promise 解决过程 是一个抽象的运算所得， 比如我们这样 [[Resolve]](promise, x)，表示输入一个promise和一个值，如果 x 是一个 thenable, 或者说假设这个 x
 看起来有点像一个promise，它会试图使 promise 采取 x的状态, 否则, 它会转变 promise的状态为fulfilled并以 x作为value。

 这种对thenables的处理使promise的实现更具有可操作性, 只要它们暴露一个Promises/A+应允的then 方法，它也允许符合Promises/A+的实现与那些具有合理 then 方法，但不符合规范的实现共存

 运行 [[Resolve]](promise, x), 会执行以下步骤:

 如果promise 和x 指向同一个object, rejectpromise,并抛出一个TypeError作为reason.
 如果 x 是一个promise, 采取它的状态[3.4]:
 如果 x 的状态是pending, promise 保持 pending状态，直到 x 状态转变为 fulfilled 或 rejected.
 如果 x 状态为 fulfilled, fulfill promise,给一个相同的value.
 如果 x 状态为 rejected, reject promise ,给一个相同的reason.
 另外, 如果x 是一个对象或者函数,
 把 x.then 作为then [3.5]
 如果在x.then 取值过程中抛出一个异常e e, rejectpromise,并把e 作为reason。
 如果 then 是一个函数, 用x调用它，并把 x as this指向x,并且接收两个参数，第一个参数是 resolvePromise, 第二个参数是 rejectPromise, 这里:
 如果 resolvePromise 被一个valuey调用, 运行[[Resolve]](promise, y).
 如果 rejectPromise 被一个reason r调用, reject promise ,并以 r作为reason.
 如果 resolvePromise 和rejectPromise 都被调用, 或者被相同的参数多次调用, 采取第一次调用的结果,忽略之后的调用。
 如果调用then 的时候抛出一个异常e,
 如果 resolvePromise 或者 rejectPromise 已经被调用, 忽略这个异常。
 否则， rejectpromise, 并把 e作为 reason.
 如果then 不是一个函数， resolvepromise ,并把 x作为value。
 如果 x 既不是一个对象也不是一个函数, fulfill promise ,并把 x作为value。
 如果一个promise被一个参与了循环的thenable链的thenable,resolved , 这样 [[Resolve]](promise, thenable) 的递归本质会使[[Resolve]](promise,
 thenable) 再次被调用, 遵循以上的算法会导致无限递归. 我们鼓励但不强制实现, 去检测在出现这种无限递归时,用一个 TypeError 作为reason去reject promise[3.6]

 注释
 这里 “平台代码” 是指 引擎, 环境, 和 promise 实现代码. 在实践中, 需要保证 onFulfilled 和 onRejected是异步执行的 , 并且应该在then 被调用的那一轮事件环结束后, 采用一个新的栈来调用，
 可以采用宏任务（’macro-task‘）机制如 setTimeout 、setImmediate, 或者微任务（“micro-task” ）机制如 MutationObserver 、process.nextTick来实现。 由于
 promise 的实现被认为是 平台代码, 它处理程序时可能本身包含一个任务队列 或者 “trampoline”。

 也就是说, 在严格模式下 this 是 undefined; 非严格模式下, this指向全局对象。

 在实现满足所有要求的情况下，可以允许 promise2 === promise1, 每一种实现都应该记录是否可以让 promise2 === promise1 ，以及什么情况下等式成立。

 一般来说，只有x符合当前实现,我们才认为它是一个真正的 x 。这个条款允许具体实现的时候可以采用一个符合规范的promise的状态。

 程序会首先 存储的一个 x.then的引用地址, 然后测试这个引用, 然后调用这个引用, 避免多次调用x.then 属性。这种防范 对确保值的一致性非常重要，因为在面对一个存储器属性时, 在取值的时候值可能发生改变

 实现不需要专门针对深度的tenable链做限制, 假定超出了这个限制的递归就是无限的。 只有真正的循环引用才会导致 TypeError; 如果一个无限的链上的 thenables都互不相同, 递归永远是正确的行为。

 CC0
 To the extent possible under law, the Promises/A+ organization has waived all copyright and related or neighboring
 rights to Promises/A+ Promise Specification. This work is published from: United States.

 Specification Changelog Credits Differences from Promises/A Implementations Compliance Tests GitHub organization
</body>

</html>